// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: appserver_sub.sql

package qx

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAppserverSub = `-- name: CreateAppserverSub :one
INSERT INTO appserver_sub (
  appserver_id,
  appuser_id
) VALUES (
  $1,
  $2
)
RETURNING id, appserver_id, appuser_id, created_at, updated_at
`

type CreateAppserverSubParams struct {
	AppserverID uuid.UUID
	AppuserID   uuid.UUID
}

func (q *Queries) CreateAppserverSub(ctx context.Context, arg CreateAppserverSubParams) (AppserverSub, error) {
	row := q.db.QueryRow(ctx, createAppserverSub, arg.AppserverID, arg.AppuserID)
	var i AppserverSub
	err := row.Scan(
		&i.ID,
		&i.AppserverID,
		&i.AppuserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAppserverSub = `-- name: DeleteAppserverSub :execrows
DELETE FROM appserver_sub
WHERE id=$1
`

func (q *Queries) DeleteAppserverSub(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAppserverSub, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const filterAppserverSub = `-- name: FilterAppserverSub :many
SELECT 
  sub.id,
  sub.appuser_id,
  sub.appserver_id,
  sub.created_at,
  sub.updated_at
FROM appserver_sub as sub
WHERE appuser_id=COALESCE($1, appuser_id)
  AND appserver_id=COALESCE($2, appserver_id)
`

type FilterAppserverSubParams struct {
	AppuserID   pgtype.UUID
	AppserverID pgtype.UUID
}

type FilterAppserverSubRow struct {
	ID          uuid.UUID
	AppuserID   uuid.UUID
	AppserverID uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) FilterAppserverSub(ctx context.Context, arg FilterAppserverSubParams) ([]FilterAppserverSubRow, error) {
	rows, err := q.db.Query(ctx, filterAppserverSub, arg.AppuserID, arg.AppserverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterAppserverSubRow
	for rows.Next() {
		var i FilterAppserverSubRow
		if err := rows.Scan(
			&i.ID,
			&i.AppuserID,
			&i.AppserverID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppserverSubById = `-- name: GetAppserverSubById :one
SELECT id, appserver_id, appuser_id, created_at, updated_at
FROM appserver_sub
WHERE id=$1
LIMIT 1
`

func (q *Queries) GetAppserverSubById(ctx context.Context, id uuid.UUID) (AppserverSub, error) {
	row := q.db.QueryRow(ctx, getAppserverSubById, id)
	var i AppserverSub
	err := row.Scan(
		&i.ID,
		&i.AppserverID,
		&i.AppuserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAppserverUserSubs = `-- name: ListAppserverUserSubs :many
SELECT
  asub.id as appserver_sub_id,
  auser.id as appuser_id,
  auser.username as appuser_username,
  auser.created_at as appuser_created_at,
  auser.updated_at as appuser_updated_at
FROM appserver_sub as asub
JOIN appuser as auser ON asub.appuser_id=auser.id
WHERE asub.appserver_id=$1
`

type ListAppserverUserSubsRow struct {
	AppserverSubID   uuid.UUID
	AppuserID        uuid.UUID
	AppuserUsername  string
	AppuserCreatedAt pgtype.Timestamp
	AppuserUpdatedAt pgtype.Timestamp
}

func (q *Queries) ListAppserverUserSubs(ctx context.Context, appserverID uuid.UUID) ([]ListAppserverUserSubsRow, error) {
	rows, err := q.db.Query(ctx, listAppserverUserSubs, appserverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAppserverUserSubsRow
	for rows.Next() {
		var i ListAppserverUserSubsRow
		if err := rows.Scan(
			&i.AppserverSubID,
			&i.AppuserID,
			&i.AppuserUsername,
			&i.AppuserCreatedAt,
			&i.AppuserUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserServerSubs = `-- name: ListUserServerSubs :many
SELECT
  asub.id as appserver_sub_id,
  asub.appuser_id,
  aserver.id,
  aserver.name,
  aserver.created_at,
  aserver.updated_at
FROM appserver_sub as asub
JOIN appserver as aserver ON asub.appserver_id=aserver.id
WHERE asub.appuser_id=$1
`

type ListUserServerSubsRow struct {
	AppserverSubID uuid.UUID
	AppuserID      uuid.UUID
	ID             uuid.UUID
	Name           string
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
}

func (q *Queries) ListUserServerSubs(ctx context.Context, appuserID uuid.UUID) ([]ListUserServerSubsRow, error) {
	rows, err := q.db.Query(ctx, listUserServerSubs, appuserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserServerSubsRow
	for rows.Next() {
		var i ListUserServerSubsRow
		if err := rows.Scan(
			&i.AppserverSubID,
			&i.AppuserID,
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
