// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: appserver_sub.sql

package qx

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAppserverSub = `-- name: CreateAppserverSub :one
INSERT INTO appserver_sub (
  appserver_id,
  appuser_id
) VALUES (
  $1,
  $2
)
RETURNING id, appserver_id, appuser_id, created_at, updated_at
`

type CreateAppserverSubParams struct {
	AppserverID uuid.UUID
	AppuserID   uuid.UUID
}

func (q *Queries) CreateAppserverSub(ctx context.Context, arg CreateAppserverSubParams) (AppserverSub, error) {
	row := q.db.QueryRow(ctx, createAppserverSub, arg.AppserverID, arg.AppuserID)
	var i AppserverSub
	err := row.Scan(
		&i.ID,
		&i.AppserverID,
		&i.AppuserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAppserverSub = `-- name: DeleteAppserverSub :execrows
DELETE FROM appserver_sub
WHERE id=$1
`

func (q *Queries) DeleteAppserverSub(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAppserverSub, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAllUsersAppserverSubs = `-- name: GetAllUsersAppserverSubs :many
SELECT 
  apssub.id as appserver_sub_id,
  apu.id,
  apu.username,
  apu.created_at,
  apu.updated_at  
FROM appserver_sub as apssub
JOIN appuser as apu ON apssub.appuser_id=apu.id
WHERE apssub.appserver_id=$1
`

type GetAllUsersAppserverSubsRow struct {
	AppserverSubID uuid.UUID
	ID             uuid.UUID
	Username       string
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
}

func (q *Queries) GetAllUsersAppserverSubs(ctx context.Context, appserverID uuid.UUID) ([]GetAllUsersAppserverSubsRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersAppserverSubs, appserverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersAppserverSubsRow
	for rows.Next() {
		var i GetAllUsersAppserverSubsRow
		if err := rows.Scan(
			&i.AppserverSubID,
			&i.ID,
			&i.Username,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppserverSub = `-- name: GetAppserverSub :one
SELECT id, appserver_id, appuser_id, created_at, updated_at
FROM appserver_sub
WHERE id=$1
LIMIT 1
`

// --- APPSERVER SUB QUERIES -----
func (q *Queries) GetAppserverSub(ctx context.Context, id uuid.UUID) (AppserverSub, error) {
	row := q.db.QueryRow(ctx, getAppserverSub, id)
	var i AppserverSub
	err := row.Scan(
		&i.ID,
		&i.AppserverID,
		&i.AppuserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserAppserverSubs = `-- name: GetUserAppserverSubs :many
SELECT 
  apssub.id as appserver_sub_id,
  aps.id,
  aps.name,
  aps.created_at,
  aps.updated_at  
FROM appserver_sub as apssub
JOIN appserver as aps ON apssub.appserver_id=aps.id
WHERE apssub.appuser_id=$1
`

type GetUserAppserverSubsRow struct {
	AppserverSubID uuid.UUID
	ID             uuid.UUID
	Name           string
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
}

func (q *Queries) GetUserAppserverSubs(ctx context.Context, appuserID uuid.UUID) ([]GetUserAppserverSubsRow, error) {
	rows, err := q.db.Query(ctx, getUserAppserverSubs, appuserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAppserverSubsRow
	for rows.Next() {
		var i GetUserAppserverSubsRow
		if err := rows.Scan(
			&i.AppserverSubID,
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
